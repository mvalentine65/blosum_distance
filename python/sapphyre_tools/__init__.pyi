from typing import List, Optional, Set, Tuple

class ReferenceHit:
    def __init__(self, target: str, sstart: int, send: int) -> None: ...
    def to_json(self) -> str: ...

class Hit:
    header: str
    target: str
    gene: Optional[str]
    frame: int
    evalue: float
    score: float
    qstart: int
    qend: int
    sstart: int
    send: int
    pident: float
    reftaxon: Optional[str]
    kick: bool
    seq: Optional[str]
    length: int
    full_header: str
    reference_hits: List[ReferenceHit]

    def __init__(
        self,
        header: str,
        ref_header: str,
        frame: int,
        evaule: float,
        score: float,
        qstart: int,
        qend: int,
        sstart: int,
        send: int,
        pident: float,
    ) -> None: ...
    def convert_reference_hits(self) -> List[str]: ...
    def to_json(self) -> str: ...

class OverlapTree:
    def __init__(self) -> None: ...
    def insert(self, tuple: Tuple[int, int]) -> None: ...
    def insert_vector(self, iterable: List[Tuple[int, int]]) -> None: ...
    def query_overlap(self, tuple: Tuple[int, int]) -> List[Tuple[int, int]]: ...

class ScoredPosition:
    location: int
    sum: float
    scores: List[float]

    def __init__(self, location: int, sum: float, scores: List[float]) -> None: ...

class ProteinMotif:
    def __init__(self, sequences: List[str]) -> None: ...
    def get_scores(self) -> List[float]: ...
    def min_score(self) -> float: ...
    def max_score(self) -> float: ...
    def degenerate_consensus(self) -> List[int]: ...
    def len(self) -> int: ...
    def is_empty(self) -> bool: ...
    def raw_scores(self, query_sequence: str) -> Optional[Tuple[int, float, List[float]]]: ...
    def score(self, query_sequence: str) -> Optional[ScoredPosition]: ...
    def info_content(self) -> float: ...

def preprocess_n_chunks(
    data: List[Tuple[str, str]],
    min_length: int,
) -> List[Tuple[str, str]]: ...
def fast_dedupe(inputs: List[str], out: str, sort_by_size: bool, min_size: int) -> None: ...
def asm_index_split(sequence: str) -> List[Tuple[int, int]]: ...
def blosum62_distance(one: str, two: str) -> float: ...
def bio_revcomp(sequence: str) -> str: ...
def constrained_distance(consensus: str, candidate: str) -> int: ...
def convert_consensus(sequences: List[str], consensus: str) -> str: ...
def len_without_gaps(x: str) -> int: ...
def dumb_consensus(sequences: List[str], threshold: float, min_depth: int) -> str: ...
def dumb_consensus_dupe(
    sequences: List[Tuple[str, int]],
    threshold: float,
    min_depth: int,
) -> str: ...
def filter_regions(sequence: str, min_length: int) -> str: ...
def consensus_distance(
    consensus: str,
    candidate: str,
    min_length: int,
    min_overlap: int,
) -> Tuple[int, int]: ...
def excise_consensus_tail(consensus: str, limit: float) -> Tuple[str, int]: ...
def find_index_pair(sequence: str, gap: str) -> Tuple[int, int]: ...
def find_first_last_character(sequence: str, character: str) -> Optional[Tuple[int, int]]: ...
def has_data(sequence: str, gap: str) -> bool: ...
def blosum62_candidate_to_reference(candidate: str, reference: str) -> float: ...
def debug_blosum62_candidate_to_reference(
    candidate: str,
    reference: str,
) -> Tuple[float, int, List[int], List[int], List[int], List[int], List[int], List[int]]: ...
def filter_nt(candidates: List[Tuple[str, str]], failed: Set[str]) -> List[Tuple[str, str]]: ...
def score_splits(ref_slice: str, splits: List[Tuple[str, int]]) -> int: ...
def simd_hamming(one: str, two: str) -> int: ...
def delete_empty_columns(raw_fed_sequences: List[str]) -> Tuple[List[str], List[int]]: ...
def join_by_tripled_index(string: str, positions_to_keep: List[int]) -> str: ...
def join_with_exclusions(string: str, column_cull: Set[int]) -> str: ...
def join_triplets_with_exclusions(
    string: str,
    exclusion1: Set[int],
    exclusion2: Set[int],
) -> str: ...
def get_overlap(
    start1: int,
    end1: int,
    start2: int,
    end2: int,
    min_overlap: int,
) -> Optional[Tuple[int, int]]: ...
def is_same_kmer(one: str, two: str) -> bool: ...
def get_overlap_percent(start1: int, end1: int, start2: int, end2: int) -> float: ...
def make_aligned_ingredients(
    clusters: List[List[Tuple[str, str]]],
    gene: str,
    aligned_files_tmp: str,
    raw_files_tmp: str,
    debug: bool,
    this_intermediates: str,
) -> List[Tuple[str, int, int]]: ...
def run_intermediate(
    cluster_file: str,
    seq_count: int,
    cluster_i: int,
    tmp_align: str,
    parent_tempdir: str,
    this_intermediates: str,
    debug: bool,
) -> None: ...
def process_clusters(
    clusters: List[List[Tuple[str, str]]],
    this_intermediates: str,
    parent_tempdir: str,
    tmp_align: str,
) -> List[Tuple[str, str]]: ...
def align_remove_empty_columns(sequences: List[Tuple[str, str]]) -> List[Tuple[str, str]]: ...
def align_remove_dashes(sequences: List[Tuple[str, str]]) -> List[Tuple[str, str]]: ...
def entropy_filter(records: List[str], entropy_threshold: float) -> List[Tuple[str, str]]: ...
def entropy(freqs: List[float]) -> float: ...
def sigclust(records: List[Tuple[str, str]], k: int, c: int) -> List[List[str]]: ...
def sigclust_with_sequence(
    records: List[Tuple[str, str]],
    k: int,
    c: int,
) -> List[List[Tuple[str, str]]]: ...
def write_fasta_compressed(path: str, records: List[Tuple[str, str]]) -> None: ...
def write_fasta_uncompressed(path: str, records: List[Tuple[str, str]]) -> None: ...
def translate(sequence: str, table: Optional[int] = ...) -> str: ...
def del_cols(sequence: str, x_positions: Set[int], is_nt: bool) -> str: ...
